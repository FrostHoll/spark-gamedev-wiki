# 2.1 Абстрактные классы и интерфейсы

Сегодня мы с вами поговорим о чем-то эфемерном, почти неощущаемом, но так сильно необходимом. О абстрактных классах и интерфейсах.

## Для чего они нам нужны?

Давайте сначала вспомним, что у нас есть классы и инструмент наследования. В классе мы описываем поля, методы. Описываем его поведение и все просто замечательно у нас.

Но давайте, на секунду представим, как у нас выглядит `животное`? А какие звуки издает животное? А как у нас атакует `враг`? Стреляет, бьет? Если бьет, то мечом или булавой?

Заметьте, вы вполне могли сейчас ответить, что кот - мяукает. И кот - животное. Все логично, но... собака - тоже животное. И собаки очень редко мяукают. Так какие звуки издает `животное`? Правильным ответом на этот вопрос будет - **никакие**. Животное - концепция, концепция не может издавать какие-либо звуки. Дайте себе минутку, чтобы это переварить.

Переварили? Отлично, приблизимся к нашим баранам. Как в нашей игре атакует `враг`? Если вы уловили мысль выше, скорее всего вы ответите - никак. Врагом может быть все что угодно: зомби, лучники, сундуки-мимики. В зависимости от того, **какой** это враг, он по-разному атакует. Но самое главное - **все враги умеют атаковать**. Чувствуете? Уже за километр несет ООП.

Чтобы получить ответ на вопрос "зачем нам нужны абстрактные классы", давайте проведем небольшой итог:

**Враг** сам по себе слишком эфемерная сущность. Непонятно **как** он выглядит, и **как** он работает. Но при этом, мы знаем, что **у всех врагов есть какое-то значение здоровья, урона**, и что **все враги умеют атаковать**. Причем **атакуют каждый по-разному**.

Давайте попробуем сразу сделать класс врага.

```csharp
class Enemy
{
    public int health;

    public int damage;

    public virtual void Attack()
    {
        
    }
}
```

Вот такой класс получается. Значения здоровья и урона будут отличаться от врага к врагу. А метод атаки мы оставляем пустым, ведь все следующие враги будут сами определять **как именно**. Оставляем у этого метода ключевое слово `virtual`, чтобы все следующие враги могли переопределять атаку.

Итак, делаем, к примеру, слизня:

```csharp
class Slime : Enemy
{
    public Slime()
    {
        health = 20;
        damage = 2;
    }

    public override void Attack()
    {
        // прыгаем на игрока и наносим damage урона
    }
}
```

Слизень у нас враг, верно? Поэтому наследуемся от него. Задаем в конструкторе значения здоровья и урона, которые ему подходят. А в методе атаки прыгаем на игрока и наносим ему урон. Пока все выглядит замечательно, да?

Давайте покажу, где все ломается:

```csharp
Enemy enemy1 = new Enemy();
enemy1.Attack();
```

Кроме очевидной проблемы, что мы не знаем, какую модельку ему накинуть, он еще и атаковать не может: метод Attack у нас в Enemy пустой. Если бы мы все же решили сделать какой-то шаблонный способ атаки в нем, сколько он урона нанесет? Даже если мы ему зададим какое-то значение урона, то как наносить по нему урон? Ведь у него нет здоровья. И так далее и тому подобное. При попытке его использовать, нам приходится придумывать конкретику, что вообще-то различается с нашими идеями.

## Абстрактные классы

Для таких случаев и были придуманы **абстрактные классы**. Они обозначают абстрактную концепцию класса, которую реализуют потомки.

В нашем случае именно враг довольно абстрактный, не правда ли?

Давайте пробежимся по различиям от обычного класса:

- Нельзя создать объект абстрактного класса. В нашем случае, мы не можем пользоваться врагом - черт его знает, что это такое.
- Можно оставлять методы не реализованными - то есть абстрактными. Это заставит его потомков их обязательно реализовать. В нашем случае - абстрактный метод это `Attack`, а наш слизень **должен** описать, как он будет атаковать.

Давайте переделаем нашего `Enemy`:

```csharp
abstract class Enemy
{
    public int health;

    public int damage;

    public abstract void Attack();
}
```

Добавились ключевые слова `abstract` перед самим классом и методом `Attack`. А фигурные скобки убраны - у нас нет способа атаки по умолчанию.

При этом класс слизня `Slime` нам менять не пришлось. Ведь необходимый теперь для реализации метод Attack мы уже переопределили.

Но поменялось кое-что важное:

```csharp
Enemy enemy1 = new Enemy(); // ошибка - нельзя создать экземпляр Enemy
enemy1.Attack();
```

Теперь мы не можем создавать объект врага. И правильно! Мы ведь понятия не имеем кто это. Но у нас ведь слизень, верно? Давайте покажу один прикол:

```csharp
Enemy slime = new Slime();
slime.Attack();
```

Заметили? Я создаю слизня, и помещаю его в переменную типа врага! И работаю с ним как с врагом! И при вызове `Attack()` у нас будет работать код именно из слизня! То есть он будет прыгать на игрока и наносить 2 урона, хотя он и представлен здесь как абстрактный враг.

Так вот, абстрактный класс Enemy - задает `контракт взаимодействия` для всех врагов, которых мы напишем далее. Контракт здесь - сделка, уговор между всеми врагами, что они будут иметь здоровье и урон, и должны уметь атаковать. И они никуда не денутся от этого.

Если мы сделаем еще лучника, то он тоже враг - у него тоже будет здоровье и урон, а в качестве атаки он будет стрелять в игрока.

При этом, мы можем работать что со слизнем, что с лучником как с врагом. Ведь у них точно есть здоровье и урон, и они могут атаковать, просто каждый делает это по-своему.

Вообще вот этот прикол, что слизня можно представить как врага, понять сразу трудно. И если вы немного не включились, я прекрасно понимаю, и это нормально. Скорее было бы странно, если вы бы поняли все сразу. Дайте себе время это осознать, а еще лучше потыкаться на практике. Но, по крайней мере, что такое абстрактный класс и зачем он нужен, вы должны были уловить.

## Интерфейсы

Сразу оговорюсь - интерфейсы это не ваши менюшки, показатели здоровья, инвентарь и так далее. Но вот название у них общее не просто так.

Интерфейсы очень схожи с абстрактными классами. Однако, если вы скажете, что это одно и то же, вас выпрут с собеседования быстрее, чем вы успеете моргнуть.

Давайте взглянем на пример такого:

```csharp
interface IBuffable
{
    void ApplyBuff(int addHP, int addDmg);
}
```

Заметьте - интерфейсы это даже не класс. У него нет ключевого слова `class`. Это уже дает нам понять, что его экземпляр создать не получится.

Давайте разберем, что вообще написано. Интерфейс называется `IBuffable`. Интерфейсы служат для описания функционала. В нашем случае - наложения эффекта в виде увеличения здоровья и урона. Каждый интерфейс обычно можно выразить в виде одного-двух слов. Каких? Классы, которые реализуют данный интерфейс - **можно баффать**. Это и переводится как `Buffable`. Все названия интерфейсов всегда начинаются с заглавной `I`. Так принято, и так проще разделять класс от интерфейсов.

В качестве примера, если интерфейс описывает функционал передвижения, то называться он будет `IMovable`. Ну вы поняли идею.

Давайте рассмотрим применение. Баффать можно не только слизня, но и всех врагов, верно? Поэтому его будет реализовывать `Enemy`. А так как `Slime` наследуется от `Enemy`, то и он автоматически его реализует.

```csharp
abstract class Enemy : IBuffable
{
    public int health;

    public int damage;

    public void ApplyBuff(int addHP, int addDmg)
    {
        health += addHP;
        damage += addDmg;
    }

    public abstract void Attack();
}
```

Если вдруг у нас будет иногда будет меняться реализация баффа у врагов, можем в реализации `ApplyBuff` поставить ключевое слово `virtual`. А если бы каждый враг по-своему реализовывал наложение баффов, то мы могли бы оставить реализацию абстрактной, чтобы заставить всех врагов определять этот функционал:

```csharp
public abstract void ApplyBuff(int addHP, int addDmg);
```

Теперь, когда у нас враги реализуют наш интерфейс, мы можем им воспользоваться из другого класса. Например, в классе какого-нибудь предмета:

```csharp
class ShieldItem
{
	public void Use(IBuffable buffable)
	{
		buffable.ApplyBuff(addHP: 100f, addDmg: -5f);
	}
}
```

Заметьте, бафф дается **сущности, которую можно баффать**, а не конкретному врагу, или врагам в целом. Это и есть **прямое** назначение интерфейсов. Теперь, если наш игрок тоже реализует интерфейс `IBuffable`, то этот предмет будет работать и на врагов и на игрока, причем код самого предмета мы не меняли. Разве не магия?

Давайте определимся с тем, зачем нам нужны интерфейсы:

- Каждый класс может наследоваться только от одного класса, а вот реализовывать интерфейсов - сколько угодно.
- Интерфейсы предоставляют контракт взаимодействия, так же как и абстрактные классы. Однако в отличие от абстрактных классов, которые отвечают за концепцию класса, интерфейсы определяют точки взаимодействия с классом. То есть методы и свойства, к которым мы можем обратиться.

## Применение интерфейсов на практике

Если то, как применять абстрактные классы, можно еще можно уловить, то на кой хрен нам сдались интерфейсы?

### Пример 1

Итак, вспоминаем наше тестирование. Конкретно 4-ое задание секции C. Давайте напомню условие:

> Вы работаете над проектом, в котором будет много объектов, с которыми можно взаимодействовать. У каждого такого объекта будет название, и описание того, что с ним можно сделать. Типы таких объектов: 
>
>**Дверь**;
>
>**Дверь с замком**;
>
>**Сундук с предметами**;
>
>**Закрытый сундук с предметами**;
>
>**Предмет, который можно осмотреть**;
>
>**Предмет, который можно осмотреть и поднять**;
>
>Опишите иерархию классов для этой системы.

С ними всеми можно взаимодействовать, поэтому берем общий класс для таких объектов. Пусть будет `Interactable`. Причем, как происходит взаимодействие с Interactable - неясно. Это наводит нас на абстрактный класс:

```csharp
abstract class Interactable
{
    public abstract void Interact();
}
```

Классы с предметами я пропущу. Давайте взглянем на кое-что интересное: двери и сундуки.

!!! note "Важно"
	Далее классы `Item` и `Key` - пустые, и они вынесены за рамки показанного кода. Мы никак с ними напрямую не взаимодействуем, они просто для наглядности. Не пугаемся, в них ничего важного нет. Совсем ничего нет.

```csharp
class Door : Interactable
{
    public override void Interact()
    {
        // открыть/закрыть
    }
}

class Chest : Interactable
{
    private List<Item> items = new();

    public override void Interact()
    {
        // открываем сундук, в котором лежат предметы items
    }
}
```

Как видите, в них ничего сложного нет. Но давайте вот что подумаем: у нас и дверь и сундук могут быть закрытыми. Да, мы можем ввести для них состояние открыто или нет:

```csharp
public bool isOpen = false;
```

И прописать метод открытия (использование ключа):

```csharp
public Key rightKey;

public void Open(Key key)
{
	if (key == rightKey)
	{
		isOpen = true;
	}
}
```

Но вот только эти строчки нам нужно прописать и в двери и в сундуке. Вообще, когда у вас возникает необходимость в разных классах писать одни и те же строчки, это **должно** наводить на вас страх: **вы уже делаете что-то не так**.

И вы, скорее всего, уже догадываетесь, что мы здесь применим. Да, легко сказать, что мы тут используем, учитывая, что мы разбираем интерфейсы. Но давайте я расскажу, как мы пришли бы к этому своим ходом:

У нас есть повторение функционала: открытие закрытых дверей и сундуков. Повторение именно функционала, ведь за понятием **закрываемости** вообще может быть все что угодно. Это не концепция, а функционал. Это и есть подводки к интерфейсу.

Итак, давайте же уже пропишем наш интерфейс `ICloseable`:

```csharp
interface ICloseable
{
    public bool IsOpen { get; set; }

    public Key RightKey { get; set; }

    public void Open(Key key)
    {
        if (!IsOpen && key == RightKey)
        {
            IsOpen = true;
        }
    }
}
```

Важное замечание - в интерфейсах мы не можем прописывать поля. Помним? Мы пишем функционал, а не часть состояния класса (за состояние считаются поля класса). Поэтому мы описываем свойства. За дополнительными пояснениями что такое свойства, бежим [сюда](https://metanit.com/sharp/tutorial/3.4.php).

Кстати, да. Обратите внимание, что в интерфейсе мы реализуем метод `Open`. Так нельзя было делать в древние времена C#. Сейчас уже так можно. И мы этим пользуемся прямо сейчас.

И теперь реализуем интерфейс на примере сундука:

```csharp
class Chest : Interactable, ICloseable
{
    private List<Item> items = new();

    public bool IsOpen { get; set; } = false;
    
    public Key RightKey { get; set; } = new Key();

    public override void Interact()
    {
        if (IsOpen)
        {
            // открываем сундук, в котором лежат предметы items
        }
    }
}
```

Как видите, при реализации интерфейса ничего толком не поменялось: добавились только два [авто-свойства](https://metanit.com/sharp/tutorial/3.4.php) `IsOpen` и `RightKey`, которые мы уже можем задать для каждого сундука отдельно. (ну еще добавилась проверка, что предметы мы не показываем, пока сундук не открыт ключом)

То, что мы выделили функционал закрываемости не только позволяет нам не повторять код (и упрощает его изменение - все лежит в одном месте), но и позволяет прикрутить этот функционал вообще к чему угодно - хоть к машине.

На досуге можете себе представить, как вы бы сделали это все без использования интерфейсов. Только не костыльно, а через выделение еще одного абстрактного класса - `CloseableInteractable` например. Там бы пришлось делать еще парочку оборотов вокруг своей оси, чтобы заставить это все завестись, а тут мы запросто все сделали.

Итого, если бы вы представили подобный ответ на тесте - получили бы 12/10. Это уже высший пилотаж. И теперь вы знаете, как это делается!

### Пример 2

Как ответить правильно в тесте это, безусловно, прикольно, но тест уже давно позади. Давайте ближе к тем баранам, с которыми вы будете работать.

Представим ситуацию. Даша и Ваня работают над двумя задачами параллельно: Даше нужно прописать хар-ки персонажа, а Ване сделать баффы. Давайте посмотрим, что Даша и Ваня успели накалякать:

```csharp
class PlayerModel
{
    private int baseHP = 100;

    private int baseATK = 10;

    public int HP
    {
        get
        {
            return baseHP;
        }
    }

    public int ATK
    {
        get
        {
            return baseATK;
        }
    }
}
```

Это код Даши. Тут все просто - базовые значения здоровья и урона, и мы определяем свойства для их публичного чтения.

!!! note "Почему класс характеристик персонажа называется PlayerModel?"
	Отличный вопрос. Это часть паттерна MVC, про который у вас были вопросы в тесте. (Бу! Страшно?) Похоже, придется найти в команде того бедняжку, который будет рассказывать всей команде, что такое MVC с точки зрения геймдева. И у меня даже есть кое-кто на уме...

```csharp
class Amplifiers
{
    private List<int> hpAmplifiers = new List<int>();

    private List<int> atkAmplifiers = new List<int>();

    public void AddHPAmplifier(int amount)
    {
        hpAmplifiers.Add(amount);
    }

    public void AddATKAmplifier(int amount)
    {
        atkAmplifiers.Add(amount);
    }

    public int GetFinalHP(int baseHP)
    {
        int finalHP = baseHP;
        hpAmplifiers.ForEach(amp => finalHP += amp);
        return finalHP;
    }

    public int GetFinalATK(int baseATK)
    {
        int finalATK = baseATK;
        atkAmplifiers.ForEach(amp => finalATK += amp);
        return finalATK;
    }
}
```

Эта дрянь уже рук Вани. У него два списка со значениями усилителей - значений, которые просто добавляются к базовым здоровью и урону соответственно. Так же Ваня заботливо оставил методы `GetFinal...`, чтобы не в ручную считать конечные здоровье и урон.

Нам вообще не это важно. Суть в том, что Даше нужно пользоваться классом Вани - ее свойства `HP` и `ATK` должны возвращать **конечные** значения здоровья и урона, а не базовые. Но есть проблема: работают они параллельно, и Ваня еще не закончил. А Даше же не хочется ждать, пока Ваня допьет свою 35231 кружку кофе и достругает уже свою задачку! Да и ей не хочется получать табуретом по башке от ментора, за то, что она задерживает задачу... Пусть он займется Ваней, верно? Отлично! Идем жаловаться ментору, что Ваня задерживается, а мы из-за этого не можем продолжить...

Стоп! Всего этого можно было бы избежать, если бы использовали **интерфейсы**. Давайте покажу как.

Итак. Отматываем время назад до написания всей этой дребедени. Договариваемся с Ваней, как можно будет получить из его кода конечные значения характеристик. Если мы взглянем на код, то увидим уже готовые методы:

```csharp
int GetFinalHP(int baseHP)

int GetFinalATK(int baseATK)
```

И... выносим это в интерфейс:

```csharp
interface IStatsFinalizer
{
    int GetFinalHP(int baseHP);

    int GetFinalATK(int baseATK);
}
```

Теперь Даша будет пользоваться этим интерфейсом, а не кодом Вани. А Ваню заставляем реализовать этот интерфейс.

Код Даши изменится следующим образом:

```csharp
class PlayerModel
{
    private int baseHP = 100;

    private int baseATK = 10;

    public IStatsFinalizer statsFinalizer;

    public int HP
    {
        get
        {
            return statsFinalizer.GetFinalHP(baseHP);
        }
    }

    public int ATK
    {
        get
        {
            return statsFinalizer.GetFinalATK(baseATK);
        }
    }
}
```

А у Вани поменялась только первая строчка класса:

```csharp
class Amplifiers: IStatsFinalizer
{
	// тот же самый код
}
```

Когда оба закончат свою работу, в ссылку к Даше можно будет спокойно передать класс Вани `Amplifiers`, ведь он реализует необходимый интерфейс `IStatsFinalizer`.

Итого что получается? Когда вы будете решать свои задачки, и ваши классы каким-либо образом будут соприкасаться с чужими, то договоритесь, как будет происходить взаимодействие и выделите это в интерфейс.

Такой подход вам даст:

- Четко видеть входные и выходные данные вашего и чужого класса;
- Позволяет пользоваться методами и свойствами классов, которые даже еще не написаны;
- Защититесь от случая, когда код, который вы используете, вдруг поменяется. У вас все еще будет интерфейс, который не меняется, а другого заставит следовать описанным договоренностям.

Если вы будете пользоваться этим, то помните кое-что важное: интерфейс для вашего класса должен появиться **раньше** вашего класса. Чтобы другие видели то, над чем вы работаете, и уже могли пользоваться вашими первичными наработками. Не будьте Ваней.

## Задание

На этот раз задание продолжает задание из [Старта по Unity](../lvl_1/1_2_unity_start.md). После того, как вы описали примерную работу, которую вам нужно проделать, попробуйте сначала описать интерфейс для ваших скриптов. На крайний случай напишите его после. Предоставьте мне все это вместе, и я скажу насколько % вы молодцы.