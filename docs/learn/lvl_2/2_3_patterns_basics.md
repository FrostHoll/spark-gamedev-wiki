# 2.3 Паттерны проектирования. Часть 1

Сегодня мы с вами посмотрим, что такое паттерны проектирования вообще, и рассмотрим несколько базовых, от которых можно отталкиваться.

## Введение

Как говорится, позвольте мне краткую историческую справку.

В 1977 году Кристофер Александер, дизайнер и архитектор, выпускает книгу **"A Pattern Language"**, в которой рассказывает о том, как повторяющиеся решения типовых задач можно быстро и удобно переиспользовать в новых проектах. Хотя он и никак не относился к программированию, но слово архитектура вы слышите здесь не в первый раз, так ведь?

Так вот, группа гениальных программистов через десять с небольшим лет очень вдохновились идеей Александера, и в итоге в 1994 году на свет появилась книга **"Design Patterns: Elements of Reusable Object-Oriented Software"**. Вылезла она из под рук **"Банды четырех"**: Эрих Гамма, Ричард Хелм, Ральф Джонсон, Джон Влиссидес. Имена запоминать необязательно, главное помнить "Банду четырех", чтобы не сильно позориться перед программистами высшего звена.

Книга описывала решения типовых задач, которые появляются при проектировании архитектуры приложений. Эти решения, которых книга насчитывала аж 23 штуки, впоследствии назовут паттернами проектирования, или просто паттернами, а затем этот список будет стремительно разрастаться с годами.

Сейчас паттерны проектирования - активно расширяющийся "фандом", и их сейчас куда больше, но они не относятся к "канону". Тот же MVC, с которым вы уже знакомы, является таковым - по сути апокриф к паттернам проектирования (простите за библейскую аллегорию). И если программист на вопрос "на каких языках ты программируешь", отвечает хотя бы один ООП язык, и при этом не знает хотя бы половины из паттернов - его резюме даже не рассматривают.

**Почему они настолько важны?**

- У паттернов указаны условия и области применения. Они помогают намного быстрее найти решение и начать реализацию, если задача достаточно типовая.
- Вряд ли под словом "машина", два разных человека будут иметь кардинально разное понимание, что это такое. Примерно такое и работает с паттернами: если вы применяете в своем решении паттерн, то все, кто с ним знаком, легко поймут, что здесь и к чему. Это сильно упрощает разработку в команде.
- Если вы будете сильно сильно думать, как решить типовую архитектурную задачу, вы рано или поздно все равно придете к одному из паттернов. А он еще и продуман намного лучше, и, заметьте, он еще и в два раза старше вас. И при этом не претерпел никаких изменений. Это явно о чем-то говорит.
- Решения этих задач, на удивление, опередили SOLID, а они этим принципам идеально придерживаются: при правильном применении паттернов код гарантированно получится чистым и расширяемым.

Вообще по канону паттерны распределены на три типа:

1. **Порождающие (Creational)** - задачи, которые возникают при создании объектов разных типов, и поддержанию их правильной связности.
2. **Поведенческие (Behavioral)** - задачи, которые возникают при описании логики поведения объектов, смены логики и так далее.
3. **Структурные (Structural)** - задачи, которые возникают при необходимости представить один класс через другой, разграничить связность, восстановить структуру объектов.

Сейчас мы с вами разберем по одному паттерну из каждого типа, которые вам с большой вероятностью пригодятся в нашем проекте. Другие, менее популярные, будут описаны в дальнейшем, в другой статье, которая выйдет уже на 3-м уровне. (если ссылки пока нет - статья пока не написана)

## Одиночка (Singleton)

Один в поле - не воин. А вот он воин, и еще какой!

### Описание

Паттерн Одиночка - порождающий паттерн, который определяет класс, у которого может быть только один экземпляр, и одну глобальную точку доступа к нему.

Это **самый простой** паттерн проектирования из существующих. И при этом его повсеместное применение - крайне осуждается. Давайте разберем сначала когда его используют:

- Когда у какого-то класса может быть только один экземпляр, которым могут пользоваться кто угодно, в любой части приложения.
- Для описания и хранения глобальных переменных.

### Реализации

Итак, работает он через статическое поле, и его классическая реализация выглядит таким образом:

```csharp
class Singleton
{
	private static Singleton s_instance = null;
	
	public static Singleton GetInstance()
	{
		if (s_instance == null)
			s_instance = new Singleton();
		return s_instance;
	}
}
```

Поле экземпляра (`s_instance`) - статическое, значит существует все время. Через статический метод `GetInstance` мы получаем ссылку на этот единственный экземпляр и работаем с ним так, как хотим. 

С точки зрения Unity реализация Одиночки выглядит таким образом:

```csharp
class Singleton : MonoBehavior
{
	private static Singleton s_instance = null;
	
	public static Singleton GetInstance()
	{
		if (s_instance == null)
		{
			s_instance = (new GameObject()).AddComponent<Singleton>();
			DontDestroyOnLoad(s_instance);
		}
		return s_instance;
	}
}
```

Так как Одиночка здесь компонент, то немного отличается его создание на сцене, а также он засовывается в метод `DontDestroyOnLoad`, что исключает его из объектов для удаления при смене сцены - после его создания он будет существовать в игре до конца работы.

Есть чуть попроще реализация, которая позволяет настраивать поля Одиночки в редакторе. Мы навешиваем скрипт на пустой объект на самой первой сцене, что дает нам возможность редактировать поля, а код уже изменится. Давайте рассмотрим на примере реализации Одиночки из моего проекта:

```csharp
public class TooltipController : MonoBehaviour
{
    private static TooltipController s_instance;

    public static TooltipController Instance => s_instance;

    [SerializeField] private Tooltip _tooltip;

    private void Awake()
    {
        if (s_instance != null)
        {
            Destroy(gameObject);
            return;
        }
        s_instance = this;
        DontDestroyOnLoad(this);
    }

    public void ShowTooltip(Tooltipable tooltipable)
    {
        // показать подсказку
    }
}

// использование
TooltipController.Instance.ShowTooltip(...);
```

Этот класс отвечает за появление подсказки при наведении на объекты. Я определяю объект подсказки `Tooltip` в редакторе, а затем через экземпляр спокойно работаю с ним, например, через метод `ShowTooltip`. Как видите, инициализация Одиночки перенесена в метод `Awake`, и если существует еще один Одиночка того же типа, то он уничтожается (это нужно, когда один и тот же компонент есть на разных сценах). Заметьте, что доступ к экземпляру описан через свойство, что не защищено от `NullReferenceException`. Можно было бы объединить эту реализацию с предыдущей, чтобы добиться идеала.

### Итог

Я уже сказал, что его повсеместное использование крайне осуждается. **Особенно в Unity**. Почему?

Ну вот подумайте. Вот есть у нас на сцене объектик, который, допустим, открывает дверь, только когда у игрока меньше 30% здоровья. Этот объект является частью дизайна уровней, а потому ему будет сложно задать ссылку на игрока (сцены загружаются динамически, поэтому игрока на них не будет). Поэтому что? Правильно - давайте сделаем игрока Одиночкой, ведь игрок всегда один, правда? Тогда этому объекту достаточно будет просто обратиться к статической ссылке и все прекрасно!

Замечаете? Как только у вас встречается проблема с получением ссылки на один единственный, не очень удобный объект, так и напрашивается Одиночка. Вот только повсеместное использование этого приносит огромное количество проблем: если не заглянем в код этого объекта, мы и не узнаем, что ему нужен игрок. Это убирает возможность протестировать его функционал без игрока. Появляется сильная связь. Причем сильная **незаметная** связь, что является проблемой в квадрате.

Пока мы еще на этой проблеме, подмечу еще одно решение, которое частенько у вас приходит в голову. Это `FindObjectByType`. Это абсолютно то же самое, только нам не нужно целевой объект делать Одиночкой. Взамен, мы должны дождаться, пока он проверит **все объекты на сцене**, а у каждого из них проверит **все компоненты**. Вы будете в шоке, когда узнаете сколько **секунд** это занимает на больших сценах. А это только один единственный вызов! А если вы везде будете такое пихать? *Ох мама...* 

Поэтому если и делаете плохо - хотя бы делайте это с честью. Так вы хотя бы получите небольшой респект за то, что воспользовались паттерном, а не вонючим костылем.

## Наблюдатель (Observer)

Большой брат следит за вами. И он говорит вам: "пора браться за работу!"

### Описание

Паттерн Наблюдатель - поведенческий паттерн, который определяет связь "один ко многим" между наблюдаемым объектом и наблюдателями. При изменении наблюдаемого объекта все наблюдатели узнают об изменении.

Его используют когда:

- Система состоит из множества классов, объекты которых должны находиться в согласованных отношениях (один ко многим).
- Взаимодействие между объектами имеет характер "событие - обработчики события".

### Реализации

Работает паттерн через делегаты и события (частными случаями делегатов), с которыми вы можете ближе познакомиться [в этой статье](2_4_unity_events.md), написанной Хасаном.

Классическая реализация, без делегатов, выглядит таким образом:

```csharp
interface IObserver // наблюдатель
{
	void Update(object message);
}

interface IObservable // наблюдаемый объект
{
	void AddObserver(IObserver o);

	void RemoveObserver(IObserver o);

	void NotifyObservers(object message);
}
```

Суть в том, что наблюдаемый объект (`IObservable`) должен хранить список наблюдателей (`IObserver`). Через методы `AddObserver` и `RemoveObserver` добавлять и убирать наблюдателей из списка, а в методе `NotifyObservers` вызывать у каждого наблюдателя метод `Update`, который при желании можно дополнить любыми параметрами.

Однако таким образом для каждой системы "наблюдаемый объект-наблюдатели", нужно будет создавать отдельные интерфейсы, прописывать реализации. Это неудобно. Хотя отчасти такая система до сих пор используется в Unity, например при реализации интерфейсов `IPointerClickHandler` и других. Просто подписка скрыта от ваших глаз.

Сейчас лучше всего реализовывать данный паттерн через делегаты, или еще лучше через Action, UnityAction и UnityEvent. О их работе вы тоже можете ознакомиться [в этой статье](2_4_unity_events.md).

Давайте на примере небольшого кода из моего проекта:

```csharp
public class ColorCell : MonoBehaviour, IPointerClickHandler
{
    public event UnityAction<int> ColorClicked; // событие по выбору цвета

	// событие по клику мыши
    public void OnPointerClick(PointerEventData eventData)
    {
        if (_isSelected || _isDone) return;
        ColorClicked.Invoke(_colorNum); // вызываем событие, что цвет изменен
        SetSelected(true);
    }
}

public class ColorPalleteController : MonoBehaviour
{
    public void InitPallete(Color[] colors) // создаем палетку
    {            
        for (int i = 0; i < colors.Length; i++)
        {
	        // создаем цвета
            var cell = Instantiate(_cellPrefab, _palleteRoot);
            // подписываемся на событие смены цвета
            cell.ColorClicked += OnColorClicked; 
        }
    }

    private void OnColorClicked(int colorIndex)
    {
        // обрабатываем событие
    }

}
```

У меня есть проект по раскраске картинок по пикселю. Там есть палетка цветов, и мне нужно менять цвет, которым мы рисуем, когда тыкаем по нужному цвету в палетке.

Здесь `ColorCell` - цвет на палетке, а `ColorPalleteController` - сама палетка с цветами. Заметьте, что тут используется и классическая реализация (`IPointerClickHandler` в `ColorCell`), и реализация через события - событие изменения выбранного цвета.

### Итог

Паттерн Наблюдатель - один из самых используемых паттернов в принципе, и он есть даже там, где вы раньше и не подозревали. Паттерн позволяет соединять объекты друг с другом, не создавая связи вообще (в случае событий), что позволяет на лету менять наблюдателей прямо во время работы. На основе этого паттерна существует отличный инструмент `EventBus`, до которого мы еще дойдем. А пока привыкайте его видеть, и, самое главное, использовать. При его реализации главное помнить - не удаляйте подписчиков во время обработки событий, и они обрабатывают события по порядку добавления их в список / делегат.

## Фасад (Facade)

Ну и последний на сегодня - Фасад.

### Описание

Паттерн Фасад - структурный паттерн, который призван скрывать сложность системы с помощью представления упрощенного интерфейса для взаимодействия с ней. Если проще: за фасадом мы скрываем огромную сложную систему, а работаем с ней только через фасад.

Его используют когда:

- Необходимо определить одну точку взаимодействия с системой.
- Необходимо определить подсистемы компонентов в сложной системе.
- Нужно уменьшить количество зависимостей между системой и клиентом.

### Реализации

На самом деле это тоже один из простейших паттернов. Потому что идея, скрывать классы в другом, вам уже знакома. Да-да: MVC - частный случай Фасада.

Давайте взглянем на классическую реализацию:

```csharp
class Facade
{
	private SubsystemA _subsystemA;
	private SubsystemB _subsystemB;

	public Facade()
	{
		_subsystemA = new SubsystemA();
		_subsystemB = new SubsystemB();
	}

	public void Operation()
	{
		_subsystemA.Do();
		_subsystemB.Do1();
	}
}

class SubsystemA
{
	public void Do() { }
}

class SubsystemB
{
	public void Do1() { }
}
```

Не уверен, нужно ли вообще здесь комментировать. Разве что нужно подметить, что все подсистемы, входящие в Фасад, должны быть скрыты, иначе смысл паттерна стирается.

Если уж говорить про MVC, то в нем `Controller` - Фасад. А `Model` и `View` - подсистемы. Клиенты взаимодействуют на подсистемы именно через Фасад (например чтобы уменьшить здоровье, что находится у `Model`, нужно вызвать метод из `Controller`, а не у `Model` напрямую).

### Итог

Этот паттерн вы, скорее всего, уже применяли где-то, и будете применять еще. Вы должны его знать, и **правильно применять**, потому что сокрытие подсистем - является важной частью написания кода.

## Заключение

Вообще один поведенческий паттерн мы уже смотрели в [хороших практиках](../lvl_4/best_practices.md#_2) - Паттерн Стратегия. И реализовывали много. И еще предстоит пощупать многие на практике. Суть всего этого - видеть и применять стандарты. Потому что изобретать велосипед, безусловно, весело. Но вот пользоваться тем, что уже давно за вас придумали - полезно и удобно. Далее нас ждут еще более веселые и сложные паттерны, которые, кстати, вы можете глянуть в любой момент времени. Правда обычно там все написано тяжелым техническим языком, а тут я попытался для вас немного упростить представление, с учетом реализаций применимых к Unity.

## Задание

Без написания хотя бы одного из этих паттернов вы вряд ли обойдетесь. Поэтому ваша задача - научиться их видеть, и в любой момент времени, если я спрошу о них, вы должны показать и объяснить, что вы тут использовали. Это и есть ваше задание.