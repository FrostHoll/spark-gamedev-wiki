# Базы ООП

## Введение

Ну что, ребятушки. Поздравляю. Вы окунаетесь в глубочайшую из пучин мира программирования - ООП. Объектно-ориентированное программирование.

Из названия ясно, что тут все ориентировано на объекты. Давайте поясню на пальцах.

У нас есть формочка для выпечки кексов. Мы закидываем туда тесто, начинку. Погружаем это все в печь и на выходе получаем вкусненький кекс с пылу с жару.

Так вот, покушаете потом. Сначала ООП. Кексы при выпечке получаются все примерно одинаковые, верно? То есть, его можно назвать **шаблоном** кексов. Мы уже потом вкладываем то, из чего должен состоять кекс, закидываем это все в печь и получаем готовый кекс.

Форма для выпечки - это наш **класс**. Шаблон, по которому мы создаем кексы - **объекты**. У каждого кекса может быть своя начинка, но они все ограничены геометрической формой - начинка не вылазит за форму. Начинка - **поле** класса, а тесто и изюм - **значение** этих полей. Мы закидываем значения в шаблон и это все в печку, роль которой играет **конструктор** или фабрика (паттерн проектирования).

Выглядит просто? Ну, пока что да. Так почему же я сказал, что ООП - пучина?

## Пытаемся осознать проблему

Суть в том, что ООП появился давно. И за это время появилось огромное количество правил написания кода в ООП, принципов и указаний. И любое отхождение от этих правил означает, что вы абсолютная бездарность и пора уже прыгать в окно.

Стоять! Закрываем окно. Вышеописанный взгляд принадлежит тем, кто писал сотни книжек по ООП и тем, кто их читал. Это не значит, что нужно им следовать на 100%, но...

И нельзя их отрицать. Они действительно помогают подойти профессионально к решению задач и предоставляют удобную работу с коллегами. Однако некоторые, даже на мой взгляд, звучат уж совсем страшно.

В пример приведу строчки из книжки "Чистый код" великого Роберта Мартина.

> FUNCTIONS SHOULD DO ONE THING. THEY SHOULD DO IT WELL. THEY SHOULD DO IT ONLY.
>
>(Перевод) У ФУНКЦИЙ ДОЛЖНА БЫТЬ ТОЛЬКО ОДНА ЗАДАЧА. И ОНИ ДОЛЖНЫ ХОРОШО С НЕЙ СПРАВЛЯТЬСЯ. И СПРАВЛЯТЬСЯ ТОЛЬКО С НЕЙ.

Далее господин Мартин говорит о том, что чуть ли не каждая строчка кода должна быть вынесена в отдельный метод. Я вообще думаю, что здесь должна быть золотая середина: нельзя все пихать в один метод, и нельзя иметь однострочные методы. Безусловно, разделение функционала по разным методам это замечательно, но вот если мы берем каждую строчку по отдельности, сколько параметров будет в каждом методе? А название? Оно хоть будет помещаться на экране? (нам ведь нужно давать описательные названия методам, не забываем)

К чему я тут вообще распыляюсь? К тому, что пока вы будете читать про ООП, и пока будете работать вместе со мной, вы будете получать много жалоб на то, что **ваш код плохой**.

Приведу несколько причин, почему я могу ни с того ни с сего заехать вам табуретом по голове:

- Не описательное название класса/поля/переменной/метода.
- Поле/метод в этом контексте должен быть закрытым.
- Эту часть нужно вынести в отдельный метод/класс.
- Эти два класса не должны быть связаны (не должны знать друг о друге).
- Над этим классом можно провести еще один уровень абстракции.
- И так далее.

Эти и многие другие причины жестокого обращения с бедными студентами взяты не с потолка. И они не существуют только потому, что о них кто-то написал, и теперь все так делают.

**Главная причина**: все принципы и правила помогают писать гибкий, расширяемый код.

Давайте на живом, моем личном примере:

В моем проекте изначально была обычная система инвентаря, которую вы могли видеть в любой другой игре. Затем я понял, что в виртуальной реальности не очень удобно кликать по табличке предметов перед собой. Поэтому я заменил ее на карманы по бокам игрока. И что вы думаете? У меня это заняло много времени? Спойлер - я дольше разбирался с тем, чтобы присобачить ко всему этому VR составляющую, чем писал код инвентаря в карманах. Скажу больше - они оба прекрасно работают, и можно использовать любой из них, по усмотрению игрока.

Круто звучит? Вы бы знали, какое наслаждение я получаю, когда работаю с кодом, который не надо 100500 раз менять для того, чтобы что-то добавить.

Я надеюсь, что вы уловили мысль. **Основная проблема** - не написать код, а **написать расширяемый код**, с которым могли бы работать другие. Это и поможет вам проще добавлять что-то новое, и с системой контроля версий, чтобы другие ребята не меняли уже написанный вами код, предварительно пытаясь в нем разобраться.

## Принципы ООП

Давайте коротко пробежимся по принципам ООП - инструментам вашего кода.

1. **Инкапсуляция** (сокрытие) - все поля и методы принадлежат объекту и они закрыты от внешних воздействий. Чтобы что-то внутри объекта поменять, нужно его об этом попросить. Вы же вряд ли сами меняете серию и номер своего паспорта?
2. **Наследование** - классы с повторяющимися полями и методами должны иметь общего предка - супер класс. Дочерние классы уже сами выбирают, каким образом работать с тем, что им досталось от предка и добавляют что-то свое. Вряд ли бензобак в машинах и мотоциклах - кардинально разные вещи, правда?
3. **Полиморфизм** - одно и то же поведение можно вызвать разными входными данными. В университет можно поступить и по баллам ЕГЭ и по результатам вступительных испытаний. Хоть это и абсолютно две разные работы, цель ведь одна - поступить в университет.

Зачем нам это все? Для того, чтобы обеспечить правильную работу объектов в нашем проекте в целом. Принципы рисуют границы того, как нужно работать с объектами, и как не нужно.

## KISS, DRY

А вот уже пошли и правила.

**KISS** - Keep it simple, stupid. Не нужно усложнять то, что того не требует. Можно начитаться всех этих правил и вытворять такую дичь, что без слез уже не взглянешь. Такую проблему называют overengineering'ом. Например, когда мы пытаемся построить нереально сложную систему классов, которой воспользуемся лишь один раз. Зачем?

**DRY** - Don't repeat yourself. Очень простой принцип, который сильно перекликается с наследованием. Вообще ООП был придуман с целью избегания многократного повторения кода через наследование: если каких-то два класса решают схожие задачи, но у одного чуть больше функционала, значит они должны быть связаны наследованием. Оно позволяет не писать тот же самый код, если он уже есть в другом месте.

## Другие

Статья уже и без того получилась большой, а вот напоследок остался лишь... **SOLID**.

Это страшная вещь, и вы уже сталкивались с ней в тесте. И о ней можно говорить долго и много, и, пожалуй, я поговорю о ней уровнем выше.

Давайте договоримся: мы не говорим о SOLID, пока я не буду уверен в том, что вы готовы это слышать. Это реально печальная штука, которая требует от вас идеального понимания вышеописанного на практике. И, я подозреваю, в ближайшее время такого не предвидится. Поэтому пишите ужасный код, нарушайте принципы SOLID, пока последствия не доберутся до вас сами.